# -*- coding: utf-8 -*-
"""GeneticQuantPlayground.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-MMQB-f1dfd_o9AYYf_vPrdVzqK5c23b
"""
import numpy as np
import random

# Initialize a population with random individuals.
def initialize_population(population_size, chromosome_length):
    population = []
    # Create a specified number of individuals.
    for _ in range(population_size):
        # Each individual is represented as an array of floating-point numbers between 0 and 1.
        individual = np.random.uniform(low=0.0, high=1.0, size=chromosome_length)
        population.append(individual)
    return population

# Evaluate the fitness of each individual in the population using a given fitness function.
def evaluate_fitness(population, fitness_function):
    fitness_scores = []
    for individual in population:
        # Calculate the fitness score for each individual.
        fitness = fitness_function(individual)
        fitness_scores.append(fitness)
    return fitness_scores

# Select the fittest individuals from the population based on their fitness scores.
def selection(population, fitness_scores, num_selected):
    selected_population = []
    
    # Select a specified number of individuals.
    for _ in range(num_selected):
        
        # Find the index of the individual with the highest score. 
        selected_index = np.argmax(fitness_scores)
        
        # Add this most fit individual to our selected_population list
        selected_population.append(population[selected_index])
        
         # Set this index's score to negative infinity so it's not re-selected in future iterations
         # This ensures we're getting unique selections every time
         # If you want to allow re-selection you can remove or comment out this line 
         # depending on your use case and how you want your selection process to work 
         
         ## Note: This could potentially lead to premature convergence by only selecting 
         ##       The same best fit individuals at every generation if left unchecked  
        
         
        fitness_scores[selected_index] = float('-inf')  
   
   return selected_population


# Perform crossover (also known as recombination) between two parents to produce two children,
# which involves swapping parts of their chromosomes at a randomly chosen point.

def crossover(parent1, parent2):

   ## Generate a random integer within valid index bounds (not inclusive) 

   crossover_point = random.randint(1,len(parent1)-1)

   ## Child 1 gets first part from parent 1 and second part from parent 2
   
   child1=np.concatenate((parent1[:crossover_point],parent2[crossover_point:]))

   ## Child 2 gets first part from parent 2 and second part from parent 1
   
   child2=np.concatenate((parent2[:crossover_point],parent1[crossover_point:]))

   
   
   return child1 ,child2 


## Introduce small random changes into an individual's chromosome at a given mutation rate.

def mutation(individual ,mutation_rate):

     mutated_individual=individual.copy()
     
     for i in range(len(mutated_individual)):
         
          if random.random() < mutation_rate:
          
             mutated_individual[i]=random.uniform(0.0 , 1.0)

     return mutated_individual
     
